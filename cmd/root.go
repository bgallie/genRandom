/*
Copyright Â© 2021 NAME HERE <EMAIL ADDRESS>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"encoding/base64"
	"fmt"
	"io"
	"io/fs"
	"math/big"
	"os"
	"path/filepath"
	"regexp"
	dbug "runtime/debug"
	"strings"
	"time"

	"github.com/bgallie/ikmachine/v2"
	"github.com/bgallie/jc1/v2"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"golang.org/x/term"

	"github.com/spf13/viper"
)

var (
	cfgFile    string
	multiplier = map[string]*big.Int{
		"":   new(big.Int).SetInt64(1),
		"c":  new(big.Int).SetInt64(1),
		"w":  new(big.Int).SetInt64(2),
		"b":  new(big.Int).SetInt64(512),
		"K":  new(big.Int).SetInt64(1000),
		"KB": new(big.Int).SetInt64(1024),
		"M":  new(big.Int).SetInt64(1000 * 1000),
		"MB": new(big.Int).SetInt64(1024 * 1024),
		"G":  new(big.Int).SetInt64(1000 * 1000 * 1000),
		"GB": new(big.Int).SetInt64(1024 * 1024 * 1024),
		"T":  new(big.Int).SetInt64(1000 * 1000 * 1000 * 1000),
		"TB": new(big.Int).SetInt64(1024 * 1024 * 1024 * 1024),
		"P":  new(big.Int).Mul(new(big.Int).SetInt64(1000*1000*1000*1000), new(big.Int).SetInt64(1000)),
		"PB": new(big.Int).Mul(new(big.Int).SetInt64(1024*1024*1024*1024), new(big.Int).SetInt64(1024)),
		"E":  new(big.Int).Mul(new(big.Int).SetInt64(1000*1000*1000*1000), new(big.Int).SetInt64(1000*1000)),
		"EB": new(big.Int).Mul(new(big.Int).SetInt64(1024*1024*1024*1024), new(big.Int).SetInt64(1024*1024)),
		"Z":  new(big.Int).Mul(new(big.Int).SetInt64(1000*1000*1000*1000), new(big.Int).SetInt64(1000*1000*1000)),
		"ZB": new(big.Int).Mul(new(big.Int).SetInt64(1024*1024*1024*1024), new(big.Int).SetInt64(1024*1024*1024)),
		"Y":  new(big.Int).Mul(new(big.Int).SetInt64(1000*1000*1000*1000), new(big.Int).SetInt64(1000*1000*1000*1000)),
		"YB": new(big.Int).Mul(new(big.Int).SetInt64(1024*1024*1024*1024), new(big.Int).SetInt64(1024*1024*1024*1024)),
	}
	source         string
	myRead         func([]byte) (int, error)
	myIntn         func(int) int
	ikengine       *ikmachine.IkMachine
	jc1Key         *jc1.Cipher
	uberJC1Key     *jc1.UberJc1
	shutdownEngine func()
	bCnt           string
	iCnt           *big.Int
	sCnt           string
	sBlock         string
	blockCount     *big.Int
	blockSize      *big.Int
	counterKey     string
	mKey           string
	outputFileName string
	GitCommit      string = "not set"
	GitBranch      string = "not set"
	GitState       string = "not set"
	GitSummary     string = "not set"
	GitDate        string = "not set"
	BuildDate      string = "not set"
	Version        string = ""
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "genRandom",
	Short: "Generate (psudo)random data using various psuedo random number generators",
	Long: `	Generate (psudo)random data using various random number generator as either
	a stream of random bytes, a stream of ASCII '0' and '1' characters,
	a stream of hexidecimal encoded bytes, or a series of X,Y coordinatges 
	within a rectangle of a given size.`,
	Version: Version,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	shutdownEngine = func() {}
	cobra.CheckErr(rootCmd.Execute())
	shutdownEngine()
}

func init() {
	cobra.OnInitialize(initConfig)
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file to use")
	rootCmd.PersistentFlags().StringVarP(&bCnt, "count", "", "", `starting block count.
The count can be a number or a fraction such as "1/2", "2/3", or "3/4".  If
it is a fraction, then the starting block count is calculated by multiply-
ing the maximal blocks generated by the ikmachine by the fraction.  Sup-
plying a count will overide the  stored count in the configuration file, 
allowing for a repeatable stream of psuedo-random data by giving the same
secret key and starting block number.`)
	rootCmd.PersistentFlags().StringVarP(&source, "source", "s", "",
		`the source of the random data.  The sources available are:
	1. ikmachine - an infinite key (with respact to the plaintext) encryption
	               machine.
	2. jc1       - a Go implementation of the JC1 pseudo random byte 
	               generator by John C. Craig.
	3. uberjc1   - a stack of 4 JC1 generators connected in series.`)
	rootCmd.PersistentFlags().StringVarP(&outputFileName, "outputFile", "o", "-", `Name of the file containing the generated pseudo-random data.`)

	// Extract version information from the stored build information.
	bi, ok := dbug.ReadBuildInfo()
	if ok {
		if Version == "" {
			Version = bi.Main.Version
		}
		rootCmd.Version = Version
		GitDate = getBuildSettings(bi.Settings, "vcs.time")
		GitCommit = getBuildSettings(bi.Settings, "vcs.revision")
		if len(GitCommit) > 1 {
			GitSummary = fmt.Sprintf("%s-1-%s", Version, GitCommit[0:7])
		}
		GitState = "clean"
		if getBuildSettings(bi.Settings, "vcs.modified") == "true" {
			GitState = "dirty"
		}
	}

	// Get the build date (as the modified date of the executable) if the build date
	// is not set.
	if BuildDate == "not set" {
		fpath, err := os.Executable()
		cobra.CheckErr(err)
		fpath, err = filepath.EvalSymlinks(fpath)
		cobra.CheckErr(err)
		fsys := os.DirFS(filepath.Dir(fpath))
		fInfo, err := fs.Stat(fsys, filepath.Base(fpath))
		cobra.CheckErr(err)
		BuildDate = fInfo.ModTime().UTC().Format(time.RFC3339)
	}
}

func getBuildSettings(settings []dbug.BuildSetting, key string) string {
	for _, v := range settings {
		if v.Key == key {
			return v.Value
		}
	}
	return ""
}

// initConfig reads in config file and ENV variables if set.
func initConfig() {
	var confPath string
	var err error
	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		// Find home directory.
		confPath, err = os.UserConfigDir()
		cobra.CheckErr(err)
		confPath = filepath.Join(confPath, "genRandom")
		viper.AddConfigPath(confPath)
		viper.SetConfigName("config")
		viper.SetConfigType("ini")
	}
	viper.AutomaticEnv()                        // read in environment variables that match
	cobra.CheckErr(os.MkdirAll(confPath, 0750)) // ensure confPath exists
	// If a config file is found, read it in.
	if err := viper.ReadInConfig(); err != nil {
		// there was an error reading the config file.  If it did not exist,
		// the create a default config file with just the engineLayout in it.
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
			viper.SetDefault("general.engineLayout", string([]rune{'r', 'r', 'p', 'r', 'r', 'p', 'r', 'r'}))
			cobra.CheckErr(viper.SafeWriteConfig())
			cobra.CheckErr(viper.ReadInConfig())
		} else {
			cobra.CheckErr(err)
		}
	}
}

// ParseNumber parses a numeric string with an optional multiplier into a number.
func ParseNumber(num string) *big.Int {
	val := new(big.Int)
	re := regexp.MustCompile(`([[:digit:]]+)([[:alpha:]]*)`)
	tokens := re.FindSubmatch([]byte(num))
	if tokens == nil {
		fmt.Fprintf(os.Stderr, "Bad numeric string format: [%s]\n", num)
		os.Exit(1)
	}
	_, ok := val.SetString(string(tokens[1]), 0)
	if !ok {
		fmt.Fprintf(os.Stderr, "Failed to convert string to a big.Int: %s\n", tokens[1])
		os.Exit(1)
	}
	mul := multiplier[string(tokens[2])]
	if mul == nil {
		fmt.Fprintf(os.Stderr, "Failed to convert string to a multiplier: %s\n", tokens[2])
		os.Exit(1)
	}
	return val.Mul(val, mul)
}

func initEngine(args []string) {
	// Obtain the passphrase used to encrypt the file from either:
	// 1. User input from the terminal (most secure)
	// 2. The 'TNT2_SECRET' environment variable (less secure)
	// 3. Arguments from the entered command line (least secure - not recommended)
	var secret string
	if len(args) == 0 {
		if viper.IsSet("GRD_SECRET") {
			secret = viper.GetString("GRD_SECRET")
		} else {
			if term.IsTerminal(int(os.Stdin.Fd())) {
				fmt.Fprintf(os.Stderr, "Enter the passphrase: ")
				byteSecret, err := term.ReadPassword(int(os.Stdin.Fd()))
				cobra.CheckErr(err)
				fmt.Fprintln(os.Stderr, "")
				secret = string(byteSecret)
			}
		}
	} else {
		secret = strings.Join(args, " ")
	}

	if len(secret) == 0 {
		cobra.CheckErr("You must supply a password.")
	}

	switch source {
	case "jc1":
		cobra.CheckErr(setupJC1(secret))
	case "uberjc1":
		cobra.CheckErr(setupUberJC1(secret))
	case "ikmachine":
		ikmachine.Mode = ikmachine.V1
		cobra.CheckErr(setupIkMachine(secret))
	default:
		// using ikmachine/v2
		cobra.CheckErr(setupIkMachine(secret))
	}
}

func setupIkMachine(secret string) error {
	// Initialize the ikmachine with the secret key and the named proforma file.
	ikengine = new(ikmachine.IkMachine).InitializeProformaEngine().ApplyKey('E', []byte(secret))
	// Get the counter key by seting the index to zero (0), encrypting an
	// cipherblock of all zeros, enncoding the results in base64.
	savedIndex := ikengine.Index() // save the current index.
	ikengine.Index(ikmachine.BigZero)
	ikengine.Input <- make(ikmachine.CipherBlock, ikmachine.CipherBlockBytes)
	counterKey = base64.RawStdEncoding.EncodeToString(<-ikengine.Output)
	ikengine.Index(savedIndex) // restore the saved index.
	random := new(ikmachine.Rand).New(ikengine)
	myRead = random.Read
	myIntn = random.Intn
	shutdownEngine = func() {
		random.StopRand()
		random = nil
		cobra.CheckErr(writeCounterToConfig(counterKey, ikengine.Index()))
		ikengine.StopIkMachine()
		ikengine = nil
	}

	// Get the starting block count.  cnt can be a number or a fraction such
	// as "1/2", "2/3", or "3/4".  If it is a fraction, then the starting block
	// count is calculated by multiplying the maximal states of the ikengine
	// by the fraction.
	if bCnt != "" {
		var good bool
		flds := strings.Split(bCnt, "/")
		if len(flds) == 1 {
			iCnt, good = new(big.Int).SetString(bCnt, 10)
			if !good {
				return fmt.Errorf("failed converting the count to a big.Int: [%s]", bCnt)
			}
		} else if len(flds) == 2 {
			m := new(big.Int).Set(ikengine.MaximalStates())
			a, good := new(big.Int).SetString(flds[0], 10)
			if !good {
				return fmt.Errorf("failed converting the numerator to a big.Int: [%s]", flds[0])
			}
			b, good := new(big.Int).SetString(flds[1], 10)
			if !good {
				return fmt.Errorf("failed converting the denominator to a big.Int: [%s]", flds[1])
			}
			iCnt = m.Div(m.Mul(m, a), b)
		} else {
			return fmt.Errorf("incorrect initial count: [%s]", bCnt)
		}
	} else {
		// Read the saved counter from the config file.
		var err error = nil
		iCnt, err = readCounterFromConfig(counterKey, ikmachine.BigZero)
		cobra.CheckErr(err)
	}

	// Now we can set the index of the ciper machine.
	ikengine.Index(iCnt)
	return nil
}

func setupJC1(key string) error {
	jc1Key = new(jc1.Cipher).New([]byte(key))
	random := new(jc1.Rand).New(jc1Key)
	myRead = random.Read
	myIntn = random.Intn
	shutdownEngine = func() {
		random.StopRand()
		random = nil
		jc1Key = nil
	}
	return nil
}

func setupUberJC1(key string) error {
	uberJC1Key = new(jc1.UberJc1).New([]byte(key))
	random := new(jc1.Rand).New(uberJC1Key)
	myRead = random.Read
	myIntn = random.Intn
	shutdownEngine = func() {
		random.StopRand()
		random = nil
		uberJC1Key = nil
	}
	return nil
}

/*
getOutputFiles will return the output file to use while generating the
random data.  If an output file names was given, then that file will be
opened.  Otherwise stdout is used.
*/
func getOutputFile() (*os.File, error) {
	var err error = nil
	var fout *os.File

	if len(outputFileName) > 0 {
		if outputFileName == "-" {
			fout = os.Stdout
		} else {
			fout, err = os.Create(outputFileName)
		}
	} else {
		fout = os.Stdout
	}

	return fout, err
}

// generatRandomStream write the (psudo)random data generate by the ikengine to a
// io.Pipe which can be read from the returned io.PipeReader.  it will generate and
// write (blockSize X blockCount) (psudo)random bytes.
func generateRandomStream() *io.PipeReader {
	blockCount = ParseNumber(sCnt)
	blockSize = ParseNumber(sBlock)
	input, output := io.Pipe()
	if !blockSize.IsInt64() || blockSize.Int64() > multiplier["MB"].Int64() {
		fmt.Fprintln(os.Stderr, "Block size must be less than or equal to 1,000,000")
		os.Exit(1)
	}
	blkSize := blockSize.Int64()
	block := make([]byte, blkSize)
	go func() {
		defer output.Close()
		blocksWritten := new(big.Int).Set(ikmachine.BigZero)
		for blocksWritten.Cmp(blockCount) < 0 {
			_, _ = myRead(block)
			_, err := output.Write(block)
			cobra.CheckErr(err)
			blocksWritten.Add(blocksWritten, ikmachine.BigOne)
		}
		fmt.Fprintf(os.Stderr, "Blocks Written: %d\n", blocksWritten)
	}()

	return input
}

func aliasNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
	switch name {
	case "blocks":
		name = "blocks=N"
	case "bs":
		name = "bs=BYTES"
	case "count":
		name = "count=N"
	case "points":
		name = "points=N"
	}
	return pflag.NormalizedName(name)
}

// checkFatal checks for error that are not io.EOF and io.ErrUnexpectedEOF and logs them.
func checkError(e error) {
	if e != io.EOF && e != io.ErrUnexpectedEOF {
		cobra.CheckErr(e)
	}
}

func readCounterFromConfig(key string, defValue *big.Int) (*big.Int, error) {
	var err error = nil
	mKey = fmt.Sprintf("counters.%s", key)
	icnt := new(big.Int).Set(defValue)
	if viper.IsSet(mKey) {
		savedCnt := viper.GetString(mKey)
		_, ok := icnt.SetString(savedCnt, 10)
		if !ok {
			icnt = nil
			err = fmt.Errorf("failed to convert the saved count to a big.Int: [%s]", savedCnt)
		} else if bCnt != "" {
			fmt.Fprintln(os.Stderr, "Ignoring the block count argument - using the value from the saved count.")
		}
	} else {
		viper.Set(mKey, iCnt.String())
		err = viper.WriteConfig()
	}
	return icnt, err
}

func writeCounterToConfig(key string, counter *big.Int) error {
	mKey = fmt.Sprintf("counters.%s", key)
	viper.Set(mKey, counter.String())
	return viper.WriteConfig()
}
